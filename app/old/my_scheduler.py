
def main():
    # Init process
    scheduler = []
    print("Algorithm for serializability and concurrency potrocol 2PL")

    # User interact, get the input from the user
    while True:
        user_input = input("Enter action (e.g., 'read 1 X' or 'write 2 Y', 'confirm' to generate scheduler): ").strip().lower()

        if user_input == 'confirm':
            break

        parts = user_input.split()

        if len(parts) != 3 or len(parts) == 0 :
            print("Invalid input format. Please enter 'read' or 'write' followed by transaction ID and resource.")
            continue

        action_type, transaction_id, resource = parts

        if action_type not in ['read', 'write']:
            print("Invalid action type. Please enter 'read' or 'write'.")
            continue
        try:
            transaction_id = int(transaction_id)
        except ValueError:
            print("Invalid transaction ID. Please enter a valid integer.")
            continue
        scheduler.append((action_type, transaction_id, resource))
        print(f"Added: {user_input}")

    # Better visualization of the scheduler generated by the user
    scheduler_str = "S : {"
    for action in scheduler:
        action_type, transaction_id, resource = action
        scheduler_str += f" {action_type}{transaction_id}({resource}),"
    scheduler_str = scheduler_str.rstrip(',')  # Remove the trailing comma
    scheduler_str += " }"
    print(f"Scheduler Obtained : {scheduler_str}")
    print(scheduler)

    #Check serializability
    is_conflict_serializable = check_serializability(scheduler)
    if is_conflict_serializable:
        print("Conflict Serializable: Yes")
    else:
        print("Conflict Serializable: No")

def check_serializability(scheduler):
    # Init precedent graph
    precedence_graph = {}
    # Scan the scheduler in order to find the conflict pair for adding edges
    for i in range(len(scheduler)):
        action_i, transaction_i, element_i = scheduler[i]
        if transaction_i not in precedence_graph:
            precedence_graph[transaction_i] = []
        
        for j in range(i + 1, len(scheduler)):
            action_j, transaction_j, element_j = scheduler[j]
            if (
                transaction_i != transaction_j
                and element_i == element_j
                and (action_i == 'write' or action_j == 'write')
            ):
                if transaction_j not in precedence_graph:
                    precedence_graph[transaction_j] = []
                precedence_graph[transaction_i].append(transaction_j)

    # Print precedent graph
    #for transaction, adjacents in precedence_graph.items():
    #    print(f"{transaction}: {adjacents}")

    # Check if the graph is acyclic.
    if has_cycle(precedence_graph):
        return False
    else:
        return True

# Function for checking if there'are cycle (use DFS search)
def has_cycle(graph):
    visited = set()
    rec_stack = set()
    def dfs(node):
        if node not in visited:
            visited.add(node)
            rec_stack.add(node)
            for neighbor in graph.get(node, []):
                if neighbor in rec_stack:
                    return True
                if neighbor not in visited and dfs(neighbor):
                    return True
            rec_stack.remove(node)
        return False

    for node in graph:
        if node not in visited and dfs(node):
            return True

    return False

if __name__ == "__main__":
    main()